bit.ly/leniviigoogledoc

Курс программирования на языке Python для начинающих  bit.ly/leniviigoogledoc

Урок 1

Видео:
https://www.youtube.com/watch?v=_qUEJ9Nvol8

Материал:
Объявление переменной, присвоение значения (целочисленное), изменение значения через присвоение нового значения.

price = 10
price = 20
price = 19


Урок 2

Видео:
https://www.youtube.com/watch?v=HTebIxlT20k

Материал:
О разнице между набором кода непосредственно в окне интерпретатора (IDLE). 
Передача переменным значения операций.
Арифметические операции + - * 
Приоритетность арифметических операций
Базовые действия с несколькими переменными

Последний фрагмент кода:

enrolled = 400
ill = 10
missing = 15
drunk = 20
total = enrolled - ill - missing - drunk

nocontrol = 50
total = total - nocontrol

print(total)






Урок 3

Видео:
https://www.youtube.com/watch?v=7xOTr1CifaE

Материал: 
Арифметическая операция деление с остатком - оператор /
Деление с выводом результата как целого числа без остатка //
Деление с выводом результата как остатка %
Однострочное комментирование кода

Код:
# Перечисление операций деления
# / обычная операция деления
#a = 10
#b = 3
#c = a/b
#print(c)

# // деление с выводом результата как целого числа без остатка
#d = 20
#e = 3
#f = d//e
#print(f)

# % деление с выводом результата как остатка
#g = 14
#h = 3
#i = g%h
#print(i)

# socks

pricesocks = 3
moneyonsocks = 50
pairsbought = moneyonsocks // pricesocks
print(pairsbought)
socksmoneyrest = moneyonsocks % pricesocks
print(socksmoneyrest)

# t-shirts

pricetshirt = 7
moneyontshirts = 50
tshirtsbought = moneyontshirts // pricetshirt
print(tshirtsbought)
tshirtsmoneyrest = moneyontshirts % pricetshirt
print(tshirtsmoneyrest)

# shirts

priceshirt = 12
moneyonshirts = 50
shirtsbought = moneyonshirts // priceshirt
print(shirtsbought)
shirtsmoneyrest = moneyonshirts % priceshirt
print(shirtsmoneyrest)

resttotal = socksmoneyrest + tshirtsmoneyrest + shirtsmoneyrest
print(resttotal)






Урок 4

Видео:
https://www.youtube.com/watch?v=xCAM2CIlsKY&list=PLbKwBvrpogbZfU50rPMmXow3aMFjIw4gk&index=4

Материал:
Многострочное комментирование кода “””  “””
Возведение в степень

Код:
# Comment text
""" Comment
multi-line
text
"""

"""
twothree = 2 ** 3
print(twothree)

multiplication = 2 * 2 * 2
print(multiplication)
"""

"""
threefour = 3 ** 4
multiplied = 3 * 3 * 3 * 3
print(threefour, multiplied)
"""


fourfive = 4 ** 5
multiplication = 4 * 4 * 4 * 4 * 4
print (fourfive, multiplication)







Урок 5

Видео:
https://www.youtube.com/watch?v=xzryoMGVdqw&list=PLbKwBvrpogbZfU50rPMmXow3aMFjIw4gk&index=5

Материал:
Тип данных строка
Конкатенация (сложение) строк 

Код:

""" Multi-line
comment
"""


# String

"""
a = 'Good day!'
b = "Good day!"
print(a)
print(b)

c = "This is Mike's bike"
print(c)

d = 'He asked me: "Do you have money?"'
print(d)
"""

# Concatenation of strings, adding strings

a = "Hello "
b = "John!"
c = a + b
print(c)

text = "We are glad to see you, dear "
texttwo = " on our site again!"
firstname = "John"
lastname = "Smith"
finaltext = text + firstname + " " + lastname + texttwo
print(finaltext)

number = "16"
numbertwo = "32"
concatenation = number + numbertwo
print(concatenation)




Урок 6

Видео:
https://www.youtube.com/watch?v=QhJ2V0tkJnA&list=PLbKwBvrpogbZfU50rPMmXow3aMFjIw4gk&index=6

Материал:
Дублирование строк с использованием оператора *
Функция измерения длины строки len()

Код:

#String

# Multiplication of strings
# Дублирование строк


"""
a = "Text" + " " 
b = a * 5
print(b)

# len()  - length

c = len('Word')
print(c)

d = len('Word ')
print(d)

f = 'Some words'
e = len(f)
print(e)
"""

a = "Fragment" + " "
b = a * 5
c = len(b)
print(c)




Урок 7

Видео:
https://www.youtube.com/watch?v=JOJ6gxEmFWQ&index=7&list=PLbKwBvrpogbZfU50rPMmXow3aMFjIw4gk

Материал:
Операция индексирования символов в строке (слева направо)
Операция обратного индексирования символов в строке (справа налево)

Код:
#String indexing

# 0, 1, 2, 3, 4, 5, 6, 7...

a = "Hello!"
print(a[0])
print(a[1])

b = a[2]
print(b)

#Backward indexing

# -1, -2, -3 ...

print(a[-3])
print(a[-2])


a[-1] = '?'





Дополнительный урок 7-3

String’и string‘ам рознь

Видео: https://www.youtube.com/watch?v=8XaZ0DIW6bg&index=17&list=PLbKwBvrpogbZfU50rPMmXow3aMFjIw4gk

Материал:

Друзья!

Я снова приветствую Вас в видеоуроке курса «Ленивый питон». И мы продолжаем изучать программирование на языке, который правильно называется пайтон.

Какое-то время я строил этот курс исключительно на подаче теоретических знаний. Я просто объяснял вам простейшие вещи, чтобы вы могли с чего-то начать. Такие теоретические уроки имеют простую нумерацию: ЛП0001, ЛП0002 и так далее.

Позже я заметил, что кое-что упускаю, тогда я стал делать дополнительные теоретические уроки. Такие уроки имеют более сложную нумерацию.

Например, ЛП0001-1, ЛП0007-2 и т.п. Я это сделал для того, чтобы сохранить в списке видео правильную последовательность.

Ещё позже я осознал, что простое слушание теории не даст знаниям закрепиться в вашей памяти. Потому что в памяти не остаются или плохо остаются факты, не связанные с реальным опытом.

И тогда я стал добавлять в курс практические задания. Они тоже пронумерованы по принципу сложной нумерации.

И я очень рад, что вам нравится выполнять эти задания.

А теперь я хочу записать фрагмент уже не на основе просто откуда-то взятой теории, а на основе полученного вами практического опыта.

И главная цель – чтобы в конце этого урока, каждый из вас осознал важность практики.

Ибо ничто так не помогает изучить лабиринт, как самостоятельное прохождение этого самого лабиринта. С ударами лбом о невидимые углы и погружением во тьму заблуждений.

Давайте обратим наше внимание на практическое задание «Манипулируем палиндромом». Если Вы не прошли это задание до сих пор, пожалуйста, найдите его в списке видеофрагментов курса на Youtube (напоминаю, адрес списка: bit.ly/lenivii) и обязательно выполните задание.

В этом задании вам нужно было взять палиндром и, используя возможность обратного индексирования символов в строке, вам нужно было вывести символы палиндрома на экран в обратном порядке.

Выполняя это задание, наш наблюдательный коллега Михаил Гудеников обнаружил, что если использовать следующий код, то при выведении на экран между символами появляются нежелательные пробелы. Код:
a = "ты моден и недомыт"
print(a[-1], a[-2], ' ', a[-3],a[-4],a[-5],a[-6],a[-7], ' ', a[-9],a[-10],a[-11],a[-12],a[-13],a[-14],a[-15],a[-17], a[-18])
print("Обратное индексирование, с применением ',' в качестве знака, соединяющего символы")
 
Михаил поступил совершенно правильно и не постеснялся опубликовать свой вопрос в комментариях.

Давайте вместе разберёмся, что произошло в коде Михаила. И это важно, потому что код Михаила – типичный подход для данного задания, т.е. таким же образом задачу решали многие другие наши коллеги. И нельзя сказать, что в данном решении содержится ошибка. Это не так, в целом задача выполнена и код корректный.

Но откуда берутся эти пробелы и как нам от них избавиться?

Чтобы нам было интереснее, давайте поработаем методом проб и ошибок. Сначала пусть будет практика, а потом теория.

Давайте проверим гипотезу, что вся проблема именно в обратном порядке строк. И выведем палиндром на печать точно таким же способом, вызывая с помощью индекса каждый символ, но применим прямое индексирование.

print(a[0],a[1], a[2], a[3],a[4],a[5],a[6],a[7],a[8], a[9],a[10],a[11],a[12],a[13],a[14],a[15],a[16],a[17])
print("Прямое индексирование, с применением ',' в качестве знака, соединяющего символы")
 
Мы видим, что результат – тот же. Между символами выводятся ненужные нам пробелы. Значит, причина вовсе не в направлении индексирования.
 
Давайте вспомним, как ещё кроме запятой мы можем объединять символы при выводе на экран. Вместо запятой мы можем использовать символ +. Давайте применим этот символ в коде.

print(a[0]+a[1]+ a[2]+ a[3]+a[4]+a[5]+a[6]+a[7]+a[8]+ a[9]+a[10]+a[11]+a[12]+a[13]+a[14]+a[15]+a[16]+a[17])
print("Прямое индексирование, с применением '+' в качестве знака, соединяющего символы")
 
Действительно, результат такой как нам нужно! Поздравляю.
И если мы заменим в варианте кода Михаила все запятые на плюсики, то всё сработает.


print(a[-1]+ a[-2]+ ' '+ a[-3]+a[-4]+a[-5]+a[-6]+a[-7]+ ' '+ a[-9]+a[-10]+a[-11]+a[-12]+a[-13]+a[-14]+a[-15]+a[-17]+ a[-18])
print("Обратное индексирование, с применением '+' в качестве знака, соединяющего символы")
 
Но, коллеги, можно ли сказать с полной уверенностью, что мы поняли, что именно мы сделали?

Пожалуй, нет. Для понимания на данном этапе многим из вас ещё не совсем достаёт знаний. И сейчас я их дам. В некотором смысле, придётся забежать вперёд, но учебному процессу это навредить не должно.

Нам придётся очень коротко набрать в легкие побольше воздуха и нырнуть на глубину знаний примерно метров сразу на 10-15. Потому что нам просто необходимо ознакомиться с понятием «встроенная функция». Я постараюсь, чтобы даже те из вас, кто ещё плохо плавает, не утонули в теории.

Что же такое встроенная функция?

Давайте запомним так: встроенные функции это самостоятельные механизмы, которые для нас создали разработчики Пайтона. Этих механизмов, то есть встроенных функций, было разработано довольно много. Каждая встроенная функция имеет своё неповторное, уникальное название. И при помощи названия мы можем эту функцию вызывать к работе, поручая ей выполнить то задание, под которое она была создана. Что делает любая «встроенная функция»? Она получает от нас информацию, перерабатывает и возвращает нам результат.
Подробно познакомиться с тем, что такое функция в принципе вы сможете аж в 35-ом уроке. Но даже самые неопытные новички из вас, коллеги, уже имеют практический опыт работы со встроенной функцией. Потому что print() это и есть встроенная в Пайтон функция.

Так вот, именно встроенная функция print() и делает то, что мы сейчас рассматриваем: именно она и выводит на экран символы то с пробелами, то без пробелов.

Почему она так поступает?

Поведение встроенной функции print(), как и любой другой встроенной функции, зависит в частности от того, что мы написали в скобки после функции. То есть, говоря научно-технически, какие параметры мы отдали функции print(). Ведь именно для получения параметров существуют эти скобочки. Назовем их принимающими скобочками.

И вот, мы начинаем свои действия над палиндромом. И нам надо решить, что отдать встроенной функции. Какие у нас есть варианты? Что мы можем отдать в качестве параметров нашей функции print()?

Давайте подумаем.

Мы можем отдать весь список проиндексированных элементов в кавычках, вот так:
"a[-1]+ a[-2]+ ' '+ a[-3]+a[-4]+a[-5]+a[-6]+a[-7]+ ' '+ a[-9]+a[-10]+a[-11]+a[-12]+a[-13]+a[-14]+a[-15]+a[-17]+ a[-18]"

Но мы то знаем, что если какой-то набор символов находится в кавычках, то этот набор – сплошная и неделимая строка, в том смысле, что это – тип данных строка/string. Встроенная функция print(), получив такую строку string, не станет её хоть как-то изменять или даже обрабатывать. Она просто выведет на экран всё содержимое string как оно есть. А мы хотим в функцию print() передать некую инструкцию, которая заставит функцию print() изменить порядок символов, взятых, из переменной а на обратный порядок. Но если мы отдадим строку (тип данных string), то есть текст в кавычках, то Пайтон не будет воспринимать её как инструкцию.

Я вам даже больше скажу, string в Пайтоне это так называемый immutable type, то есть неизменяемый тип. Тип, который не может mute – мутировать, изменяться. Но это сейчас не так важно, просто запишите себе в глубины подсознания. Просто услышьте и обязательно забудьте. (Это такой трюк. Если поставить перед собой задачу что-то забыть, то забывание значительно замедляется).

Рассмотрим ещё один вариант. Мы можем отдать встроенной функции print() всю нашу конструкцию без кавычек. Что мы и сделали. Но тогда получается, что мы не уверены, отдали мы функции print() тип данных строка/string или не строка/string? Ведь кавычек нет. А мы знаем, что строка/string это то, что в кавычках. Что же на самом деле мы отдали функции print(), когда передавали конструкцию с плюсиками? Что это за конструкция такая?

a[-1]+ a[-2]+ ' '+ a[-3]+a[-4]+a[-5]+a[-6]+a[-7]+ ' '+ a[-9]+a[-10]+a[-11]+a[-12]+a[-13]+a[-14]+a[-15]+a[-17]+ a[-18]

В Пайтон есть инструмент, который поможет нам найти ответ. Этот инструмент – ещё одна встроенная функция. type()

Эта функция делает приблизительно следующее. Я сейчас немного буду искажать реальность, потому что иначе объяснение затянется надолго. Итак, когда функция type() получает в скобках какой-то фрагмент кода, функция type() пытается понять, является ли этот элемент целостной единицей с точки зрения системы. Если функция видит, что это – не целостная единица, то она сообщает ошибку. Если же функция  type() определяет, что информация в скобках это целостная единица, то функция сообщает нам, к какому типу данных относится эта единица.

Итак, давайте передадим в функцию type() наш набор данных, чтобы узнать, что представляет из себя этот набор с точки зрения системы.

Вот наша конструкция:

a[-1]+ a[-2]+ ' '+ a[-3]+a[-4]+a[-5]+a[-6]+a[-7]+ ' '+ a[-9]+a[-10]+a[-11]+a[-12]+a[-13]+a[-14]+a[-15]+a[-17]+ a[-18]

Чтобы передать её в функцию type(), эту конструкцию мы переносим в принимающие скобки функции type(). Вот так:

type(a[-1]+ a[-2]+ ' '+ a[-3]+a[-4]+a[-5]+a[-6]+a[-7]+ ' '+ a[-9]+a[-10]+a[-11]+a[-12]+a[-13]+a[-14]+a[-15]+a[-17]+ a[-18])

Теперь, если мы выполним только что созданный код, система определит тип нашей конструкции. Но мы этого не увидим, потому что чтобы сообщение о типе конструкции вывести на экран, нам надо использовать встроенную функцию print().

То есть, мы берём всю нашу функцию type() и передаём её в принимающие скобки функции print().

Это будет выглядеть вот так:
print(type(a[-1]+ a[-2]+ ' '+ a[-3]+a[-4]+a[-5]+a[-6]+a[-7]+ ' '+ a[-9]+a[-10]+a[-11]+a[-12]+a[-13]+a[-14]+a[-15]+a[-17]+ a[-18]))

Да, я знаю, выглядит громоздко. Но результат стоит того.

Итак, выполним код. И увидим надпись class str. Str это сокращение от string.
Ура! Мы убедились в том, что мы отправляем в функцию print() строку/string…

И тут я должен сделать драматическую чеховскую паузу.

Потому что те из вас, коллеги, кто ещё не заснул, скажут: «Стоп. Ничего не понятно. Мы же только что, каких-то пять минут назад говорили, что мы передаём в функцию print не совсем строку, потому что передаваемая конструкция не включена в кавычки…»

Да, друзья, всё верно. Получается, что стринги стрингам рознь. Ведь если включить содержимое строки в кавычки, то оно не обрабатывается, а если не включать, то оно – обрабатывается.

Убедимся ещё раз в нашей безошибочности.

Передадим в сочетание функций print() и type() сначала конструкцию с кавычками

print(type("a[-1]+ a[-2]+ ' '+ a[-3]+a[-4]+a[-5]+a[-6]+a[-7]+ ' '+ a[-9]+a[-10]+a[-11]+a[-12]+a[-13]+a[-14]+a[-15]+a[-17]+ a[-18]"))

Главное, что тип данных совершенно тот же – строка.
 
То есть, передав в функцию print() конструкцию без кавычек:

a[-1]+ a[-2]+ ' '+ a[-3]+a[-4]+a[-5]+a[-6]+a[-7]+ ' '+ a[-9]+a[-10]+a[-11]+a[-12]+a[-13]+a[-14]+a[-15]+a[-17]+ a[-18]

мы заставили оператор обратиться к каждому индексу переменной а и собрать тип данных string.

И тут бы нам успокоиться да пойти гонять чаи с кофеями, нахваливая себя за смекалку да упорство в деле прогрызания гранита науки.

Но неугомонный червячок любопытства возьми да и спроси: «Как-то мне непонятно. А почему, если я вместо плюсика использую в этой конструкции запятую, то результат другой – появляются пробелы после каждого символа, взятого из переменной а. Это что уже не тип данных string получается? А какой тогда это тип данных?»

А давайте выясним, что это за тип данных. Благо дело, мы теперь умеем пользоваться функцией type().

Берём нашу конструкцию с запятыми и отправляем в функцию type.  

print(type(a[-1], a[-2], ' ', a[-3],a[-4],a[-5],a[-6],a[-7], ' ', a[-9],a[-10],a[-11],a[-12],a[-13],a[-14],a[-15],a[-17], a[-18]))

Выполним этот код.

И – ой. Что-то пошло не так. Мы получили ошибку. TypeError: type() takes 1 or 3 arguments

Система говорит нам устами ошибки: «Друзья, функция type() может принимать либо 1, либо 3 аргумента, а у вас их и не один, и не три».

Хм. Получается, что мы отдали в принимающие скобки конструкцию, которая не воспринимается системой как одна целая конструкция. Что же делать?
Есть одна хитрость. Надо включить всю нашу конструкцию в ещё одну пару скобок.

print(type((a[-1], a[-2], ' ', a[-3],a[-4],a[-5],a[-6],a[-7], ' ', a[-9],a[-10],a[-11],a[-12],a[-13],a[-14],a[-15],a[-17], a[-18])))

Выполним этот код. И вот теперь мы видим следующее.
<class 'tuple'>

Получается, что при перечислении через запятую индексированных символов из переменной а мы создали не тип данных строка/string, а какой-то tuple.
Друзья, tuple это тип данных «кортеж».

Мы ещё обязательно его изучим.

Но главное, что Вы должны были понять сейчас это то, что когда вы перечисляете элементы через запятую, вы не осуществляете конкатенацию (объединение) строк, которое приводит к созданию типа данных строка/string. Вы осуществляете создание типа данных кортеж/tuple.

Поэтому встроенная функция print() по-разному вела себя с вариантом кода, когда перечисление происходит через плюс или через запятую.

Отсюда и эти пробелы.
 
Друзья! Я надеюсь, мне удалось бросить свет хотя бы на кусочек огромного лабиринта знаний под названием Пайтон.

Я приложил максимум усилий, чтобы помочь вам разобраться. Подготовка такого урока занимает почти целый день.

Если кому-то не удалось понять большинства из того, о чём здесь рассказывалось, просто идите дальше по программе курса. Со временем вы сможете вернуться к этому фрагменту и снова его просмотреть.

Надеюсь, что к моменту публикации этого видеофрагмента, текст и коды будут опубликованы в гуглодокументе по адресу: bit.ly/googledoc




Урок 8

Видео:
https://www.youtube.com/watch?v=TyETvhRPJQY&list=PLbKwBvrpogbZfU50rPMmXow3aMFjIw4gk&index=8

Материал:
Операция получения доступа к срезам или извлечение среза

#Slicing

a = 'Hello world!'
b = a[0:6]
print(b)

# a[2:5}  0,1,[2,3,4,]5

#Backward indexing

c = a[0:-3]
print(c)

p = 'Я помню чудное мгновенье: Передо мной явилась ты, Как мимолетное виденье, Как гений чистой красоты.В томленьях грусти безнадежнойВ тревогах шумной суеты,Звучал мне долго голос нежныйИ снились милые черты.Шли годы. Бурь порыв мятежныйРассеял прежние мечты,И я забыл твой голос нежный,Твои небесные черты.В глуши, во мраке заточеньяТянулись тихо дни моиБез божества, без вдохновенья,Без слез, без жизни, без любви.Душе настало пробужденье:И вот опять явилась ты,Как мимолетное виденье,Как гений чистой красоты.И сердце бьется в упоенье,И для него воскресли вновьИ божество, и вдохновенье,И жизнь, и слезы, и любовь.'
print(p)

print(len(p))

print(p[99:101]+p[199:201]+p[299:301]+p[399:401]+p[499:501]+p[599:601])





Урок 8-1

Видео:

Материал:

Срез строки – Углубляем знания
 
Это – дополнительный урок по теме slice – срез. Один урок на эту тему у нас уже был. Предназначение этого урока: расширить Ваш набор приёмов программирования именно в том, что касается срезов.

Почему Вам это нужно? Потому что знания по теме «срезы», полученные однажды, на примере строк, могут быть применены и в будущем, для таких типов данных как список или кортеж. Хотя, сразу отмечу, что для типов данных список или кортеж срезы предоставляют больше возможностей.

Но на данный момент мы изучили тип данных “строка” и поэтому урок строим применительно к этому типу данных.

В начале тезисно повторим всё то, что мы узнали про slice из прошлого урока.
Slice это выборка из диапазона символов, в которой мы указываем индекс начального и индекс конечного символа, отсчет начинается с нуля.

Диапазон выборки должен быть дан в квадратных скобках, значения начального и конечного индексов отделяются двоеточием.

Квадратные скобки должны быть размещены сразу после имени элемента, к которому будет применён срез.

Пример:
element = 'Это текстовая строка, к которой будет применён срез'
print(element[2:9])
 
В качестве значения индекса могут быть использованы 0, положительные или отрицательные числа.

Срез применяется к типу данных строка (string). К другим тоже, но об этом – в других уроках.
 
Вот вроде бы и всё, что нам известно про срезы на данный момент. Теперь изучим совсем небольшой фрагмент новой теории.
Во-первых, нужно понять, что получается, когда мы создаём срез. Создаётся ли новый элемент в памяти? Чем он является? Строкой или чем-то другим?

Во многих языках программирования есть такое понятие как подстрока (substring). И мы имеем право утверждать, что при срезе со строки в Пайтоне мы тоже получаем подстроку. 

Но подстрока это не отдельный тип данных, а просто фрагмент строки. 

И если мы сообщаем Пайтону следующий код:
a =  'Некий текст, присвоение которого превратит а в тип данных строка'
print(a[0:10])

то правильно говорить, что мы выводим на экран подстроку от значения, присвоенного переменной а. То есть переменная a это у нас самостоятельный объект, типа строка, а мы обратились к подстроке - то есть к фрагменту строки этого самостоятельного объекта.

А вот если мы сделаем немного иначе:
a =  'Некий текст, присвоение которого превратит а в тип данных строка'
b = a[0:10]
print(b)

то будет создан новый самостоятельный объект - переменная b. И этот объект унаследует тип от переменной a. То есть, переменная b наследует тип данных строка. А в качестве значения переменной b присваивается результат среза по индексу, примененному к переменной a. 

a =  'Некий текст, присвоение которого превратит а в тип данных строка'
b = a[0:10]
print(a)
print(b)

Сохранится ли между объектом a и объектом b связь? То есть, нужно ли нам опасаться, что, изменив значение переменной a уже после объявления переменной b и присвоения её значения в виде среза, мы повлияем на значение переменной b?

Нет, опасаться не нужно. A и b это полностью самостоятельные объекты. При помощи данного кода мы можем это проверить.


a =  'Некий текст, присвоение которого превратит а в тип данных строка'
b = a[0:10]
print(a)
print(b)
a = '10101010101010101010101010101010101010101010101010101010'
print(a)
print(b)

Мы видим, что изменение значения объекта a не повлияло на изменение значения объекта b.
 
 
Это была теория, а теперь практика.
Что будет, если не указать один из индексов среза?
Проверим на практике.
Объявим переменную и присвоим ей в значение строку.
a = 'Арахнофобия'
Выводим срез:
print(a[:2])
 
Мы получили подстроку (substring) «Ар». Значит, индексы 0, 1 были включены в срез, а индекс 2 – не был включён. То есть, если мы не указываем начальный индекс, то система предполагает, что начальный индекс – 0.
 
Теперь попробуем указать только первый индекс, не указав последний.
a = 'Арахнофобия'
print(a[2:])

Мы получили подстроку (substring) «ахнофобия». Значит, индексы 2 и все последующие были включены в срез.  То есть, система исходила из предположения, что самый последний доступный индекс и должен быть установлен в качестве конечного индекса.

Какой в этом приёме практический смысл?
Мы можем делать срезы со строк, точную длину которых не знаем.
 
 
Ещё один чисто практический пример.
Что будет, если не указать ни один из индексов среза?
Логично предположить, что в таком случае подстрока не будет создана вовсе или будет содержать индексы всей строки.
Проверяем:
a = 'Арахнофобия'
print(a[:])

Да, подстрока содержит все индексы строки.

Какой в этом приёме практический смысл?
Мне он не известен, если кто-то знает, оставьте под видео комментарий, пожалуйста.
 
И ещё один пример, немного неожиданный.
Если применить вот такой код, с двумя двоеточиями:
a = 'Канатоходец'
print(a[::3])
то результатом выполнения будет срез 'Кахе'
Что произошло? В срез вошли символы с индексом 0, 3, 6, 9

Мы только что сделали пошаговый срез. Мы не указали начальный и конечный индексы, а указали только интервал, «шаг».

И, конечно же, никто не помешает нам указывать и начальный, и конечный индексы, когда мы используем срезы с пошаговым интервалом.

a = 'Канатоходец'
print(a[2:11:3])

Мы получили срез с индексами 2, 5, 8. Заметьте, что первым в срезе стал индекс, указанный на первой позиции. Затем просто значение этого индекса увеличивалось на величину шага.
 
Какой в этом приёме практический смысл?
Мы можем извлекать символ, задавая интервал, при этом не важно, известна ли нам длина строки или неизвестна.
 
Ещё совсем немного интересной теории. Вы можете вкладывать срезы в срезы. Давайте попробуем.
 
alphabet = 'AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz'
capital_letters = alphabet[::2]
print(capital_letters)
first_three_capital_letters = capital_letters[0:3]
print(first_three_capital_letters)
first_two_capital_letters = first_three_capital_letters[0:2]
print(first_two_capital_letters)
 
И пусть за этим не стоит какое-то особенное техническое решение, это просто применение срезов к объектам, созданным через применение срезов. Но всё же в этом коде мы видим всю безграничность возможностей по использованию срезов и срезов от их производных.
Какой в этом приёме практический смысл?
Могут возникнуть самые различные, нетипичные варианты.
 
Теперь Вы можете тремя способами обратиться ко всему диапазону среза. Первый способ – это не применять срез вообще :)
alphabet = 'AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz'
print(alphabet)
 
Второй способ – указать начальный индекс 0 и конечный – реальный доступный индекс.
alphabet = 'AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz'
print(alphabet[0:52])
 
Третий способ – не указывать начальный и конечный индексы.
alphabet = 'AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz'
print(alphabet[:])
 
Есть и четвёртый способ.
Можно сложить два среза, т.е. провести конкатенацию строк.
Например, так:
alphabet = 'AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz'
a = alphabet[:5]
b = alphabet[5:]
print(a+b)
Надо заметить, что индекс «5» здесь выбран случайно.
  
Забегая немного вперёд, отмечу, что срезы могут применяться к таким типам данных как строка, список и кортеж, поскольку они относятся к категории sequence object – объект-последовательность. Название объект-последовательность вроде бы громоздкое и страшненькое, но ничего особенного: строка это ведь, как нам уже сейчас известно, просто последовательность символов. А список и кортеж мы изучим позже.
 
И напоследок, демонстрация красоты срезов. При помощи очень простой и лаконичной конструкции можно получить обратный порядок симоволов строки. Делается это так:
a[::-1]
Например:
alphabet = 'АБВГД'
reverse = alphabet[::-1]
print(reverse)



Урок 9

Видео:
https://www.youtube.com/watch?v=z5FepxKfifk&index=9&list=PLbKwBvrpogbZfU50rPMmXow3aMFjIw4gk

Материал:
Строчный метод типа данных строка .capitalize() - Начинать содержимое строки с заглавной буквы
Строчный метод типа данных строка .upper() - Перевести все буквы в строке в верхний регистр
Строчный метод типа данных строка .lower() - Перевести все буквы в строке в нижний регистр
Строчный метод типа данных строка .title() - Перевести первые буквы каждого слова в строке в верхний регистр
Строчный метод типа данных строка .swapcase() - Сменить регистр всех букв в строке на противоположный

Код:

"""
Operations with strings:

Concatenation
string3 = string1 + string2

Multiplication
string2 = string1 * n

Indexing
string2 = string1[0]

Slicing
string2 = string1[2:5]

"""

"""
Functions:
string2 = len(sting1)
"""


""""
Methods

.capitalize()
.upper()
.lower()
.title()
.swapcase()

"""

a = 'Kick The Ball Before The Ball Kicks You!'
print(a.swapcase())

b = a.swapcase()
print(b)






Урок 10

Видео:
https://www.youtube.com/watch?v=yMhSD7TsvzU&index=10&list=PLbKwBvrpogbZfU50rPMmXow3aMFjIw4gk

Материал:
Строчный метод find() - поиск по содержимому строки слева направо, выводится индекс найденного элемента
Строчный метод rfind() - поиск по содержимому строки справа налево, выводится индекс найденного элемента
Строчный метод index() - поиск по содержимому строки слева направо, выводится индекс найденного элемента
Строчный метод rindex() - поиск по содержимому строки справа налево, выводится индекс найденного элемента
Строчный метод replace() - поиск по элементам строки, строгое совпадение по регистру, замена на указанный элемент

Код:

"""
String Methods

.capitalize()
.upper()
.lower()
.title()
.swapcase()


.find()
.rfind()
.index()
.rindex()
.replace('x', 'X')

a = "Hit the ball before it hits you!"
b = a.find('it')
c = a.rfind('it')
print(b)
print(c)

a = "Hit the ball before it hits you!"
b = a.index('m')
c = a.rindex('m')
print(b)
print(c)

"""
a = "Hit the ball before it hits you!"
b = a.replace('H', 'K')
print(b)





Урок 11

Видео:
https://www.youtube.com/watch?v=BNIwE2JLRms&index=11&list=PLbKwBvrpogbZfU50rPMmXow3aMFjIw4gk

Материал:
Строчный метод split() - Метод для дробления строки с возможностью указать максимальное количество дроблений.

Код

a = "Let there be light! Ö Because we want to fight! Ö All right!"
b = a.split('Ö')
print(b)




Урок 12

Видео: 
https://www.youtube.com/watch?v=e2pkLV9nz-U&index=12&list=PLbKwBvrpogbZfU50rPMmXow3aMFjIw4gk

Материал:
Строчный метод join() с применением списка

Код:
list = ['Let', 'there', 'be', 'light!']
variable = " ".join(list)
print(variable)


list = ['Let', 'there', 'be', 'light!']
variable = " "
variabletwo = variable.join(list)
print(variabletwo)


string = ' ' 
list = ['Let', 'there', 'be', 'light!'] 
print(string.join(list))





Урок 13

Видео:
https://www.youtube.com/watch?v=mKD70t2L-y4&index=13&list=PLbKwBvrpogbZfU50rPMmXow3aMFjIw4gk

Материал:
логические булевы операторы 

a = 4
b = 3

!=
<>
>
<
>=
<=

print(a != b)
print(a <> b)
print(a > b)
print(a < b)
print(a >= b)
print(a <= b)





Урок 14

Видео:
https://www.youtube.com/watch?v=o_BRbxTrKAk&index=14&list=PLbKwBvrpogbZfU50rPMmXow3aMFjIw4gk

Материал:
Оператор ветвления if

if

if statement
condition statement
branch construct
branching statement
decision statement

"""


"""
if (condition):
    command
"""

marsians = 52
cyborgs = 48

print('Hello Earth! This is the beginning of report from Mars.')

if(cyborgs > 51):
    print('Mission accomplished! Cyborgs have captivated Mars!')

if(cyborgs < 51):
    print('We are still in process of captivating Mars.')

print('End of report. Your cyborgs.')




Урок 15

Видео:
https://www.youtube.com/watch?v=RQg9IPpGg1Y&list=PLbKwBvrpogbZfU50rPMmXow3aMFjIw4gk&index=15

Материал:
Ветвление if else


"""
if (condition):
    command
else:
    command

"""

marsians = 40
cyborgs = 60

print('Hello Earth! This is the report on Mars occupation.')

if(cyborgs > 51):
    print('Mission accomplished! Cyborgs have occupied Mars!')

else:
    print('We are still in process of Mars occupation.')

print('End of report. Your cyborgs.')





Урок 16

Видео:
https://www.youtube.com/watch?v=tsm2VasOziE&index=16&list=PLbKwBvrpogbZfU50rPMmXow3aMFjIw4gk

Материал:

Ветвление if elif else



"""
if condition:
    command
else:
    command
"""

"""
if condition:
    command
elif conditiontwo:
    command
elif conditionthree:
    command
elif conditionfour:
    command
else:
    command
"""


# marsians = 100
cyborgs = 51

print('Hello Earth! This is the report on Mars occupation.')

if cyborgs >= 51:
    print('Mission accomplished! Cyborgs have occupied Mars!')
elif cyborgs > 41 and cyborgs < 51:
    print('Mission is nearly accomplished. We are close to completion')
elif cyborgs > 26 and cyborgs <= 41:
    print('Mission in progress, we are in the second half.')
elif cyborgs > 10 and cyborgs <= 26:
    print('Mission in progress, we are still in the first half.')
elif cyborgs >= 0 and cyborgs <= 10:
    print('Mission is still on the early stage.')
else:
    print('We are still in process of Mars occupation.')

print('End of report. Your cyborgs.')







Урок 17

Видео:
https://www.youtube.com/watch?v=msARLRztSgQ&index=17&list=PLbKwBvrpogbZfU50rPMmXow3aMFjIw4gk

Материал:
Логические операторы and or not

Код:

    """
and
or
not
"""

"""
if TRUE and TRUE:
    command

if TRUE or TRUE:
    command

if TRUE or FALSE:
    command
    
if FALSE or TRUE:
    command

if not:
    command

"""

price = 10
money = 9
condition = money > price

if not condition:
    print('You may board the bus!')







Урок 18

Видео:
https://www.youtube.com/watch?v=Q8AniIOulCU&list=PLbKwBvrpogbZfU50rPMmXow3aMFjIw4gk&index=18

Материал:
Списки (list)

Код

"""
Lists
"""
list = [2, 'This is a string!', 'Table is rectangular']


John = ['30', 'reading', 'married']
Bob = ['29', 'travelling', 'not married']
Mike = ['35', 'blogging', 'married']

myfriends = [John, Bob, Mike]
print(myfriends)







Урок 18-1

Материал:
Кортежи (tuple)

Сегодняшний урок – о кортежах. Это – один из дополнительных уроков, дополнительные уроки записываются после довольно продолжительной серии основных уроков и размещаются между основными уроками. Поэтому если у Вас сложится впечатление, что качество записи или стиль дополнительного урока сильно отличаются от его основного урока – это стало возможным из-за большой разницы во времени создания между основными и дополнительными уроками.
Кортежи по своей природе очень похожи на списки. Поэтому я собираюсь разместить этот урок в курсе «Ленивый питон» сразу после урока по спискам.
 
Что такое кортежи? Кортежи это тоже объекты. А мы помним, что в Пайтоне все самостоятельные единицы информации являются объектами.
Каковы признаки такого объекта как кортеж?
1.       Первый признак. Кортеж обозначается не при помощи квадратных скобок, как список, а при помощи обычных круглых скобок. Простейший пример:
a = (1, 1, 2 , 3, 5, 8)
 
Но сразу запомните, что одни лишь круглые скобки не превращают данные в кортеж автоматически, всё чуть сложнее. То есть, такой признак как круглые скобки – не решает всего, учитываются и другие признаки. И в этом Вы совсем скоро убедитесь.
 
2.       Второй признак это тот, что элементы кортежа перечисляются через запятую. И вот сочетание таких признаков как круглые скобки и запятые при перечислении элементов помогают системе определиться с решением, что этот тип данных – именно кортеж.
 
И сейчас мы с Вами в этом убедимся. Ведь согласно такой логике, кортеж должен быть способным состоять даже только из одного элемента.
 
Давайте пробовать так, создадим переменную и попробуем сначала задать кортеж без использования запятой.
a = (1)
Теперь давайте проверим получившийся тип данных, кортеж ли это. Для этого мы используем функцию type(), вызыванную через функцию print(), о таком способе я рассказывал в одном из дополнительных уроков.
a = (1)
print(type(a))
И мы видим, что получившийся у нас тип данных – int, целое число, интеджер. Это не кортеж.
 
Теперь вносим лёгкое изменение:
a = (1,)
print(type(a))
 
И мы получаем тип данных кортеж. Что и требовалось доказать.
 
Кстати оригинальное английское название этого типа данных -  tuple. Читается как тьюпл или тьюпэл. Ударение на ю.
3.       Может ли кортеж, как и список, содержать в себе элементы разных типов? Давайте попробуем.
 
a = ('To be or not to be?', 1, 4.5, True)
print(a)
print(type(a))
 
Мы видим, что кортеж совершенно спокойно содержит в себе строку, целое число, вещественное число и булев тип данных. При этом проверка показывает, что тип данных всей этой конструкции как единого целого – кортеж.
 
Пришло время задать себе вопрос. Если существует такой тип данных как список (list), то зачем вообще нужны эти кортежи? Я попробую объяснить.
1.       Операции с кортежами как правило происходят быстрее, чем операции со списками. Вы можете спросить: ну, как так – быстрее? Разве скорость важна? Ведь современные компьютеры проводят вычисления на гигантских скоростях. Всё происходит за какие-то доли секунды, какая разница, быстрее или медленнее? А я отвечу: разница в несколько долей секунды в некоторых случаях может привести к серьёзным проблемам. Потому что в некоторых ситуациях задержки имеют свойство накапливаться. А значит, если Вы можете использовать кортеж вместо списка, так и поступайте. Однозначно предпочтительнее кортежи в сравнении со списками в том случае, если Вам нужно будет перебирать элементы Вашего массива данных, не изменяя их в процессе.
2.       Тогда Вы, как мыслящий человек, спросите: а за счёт чего достигается быстродействие? Не за счёт ли ограничения возможностей? И будете совершенно правы. Кортежи имеют меньше возможностей по изменению своего содержания, чем списки. Помните, мы изучали методы для строк? Напомню, методы это такие встроенные инструменты, которые можно применять по отношению к объектам. Мы ещё запоминали, что методы отделяются от названия объекта точкой. Так вот, с объектом типа «кортеж» нельзя применять некоторые методы, которые можно применять с объектом типа «список». Например, с кортежами не применяются методы .append, .extend , то есть нельзя просто взять и добавить в кортеж кусок информации. Больше того, кортеж является неизменяемым типом данных, поэтому из него нельзя также и удалять данные без присвоения нового значения всему кортежу. А значит такие методы как .pop или .remove с кортежами тоже не действуют. В общем, кортежи это такие защищенные от случайных изменений списки. Кстати, в следующих уроках у нас уже запланирован отдельный урок про методы кортежей и списков.
 
Интересно, что есть возможность превращать другие типы данных в кортеж. Достигается такой результат при использовании функции tuple(). Давайте проведём испытания.
a = [1, 'Words', 5.2]
b = tuple(a)
print(type(b))
 
Мы создали переменную а, которой присвоили в качестве значения список. Затем создали переменную b, которой присвоили результат вызова функции tuple() с передачей этой функции переменной а в качестве аргумента.
Вывод: мы можем конвертировать тип данных список в кортеж.
 
Кстати, есть возможность совершить и обратное действие. При помощи функции, которая называется, как несложно догадаться, list(). Давайте в этом убедимся.
a = [1, 'Words', 5.2]
b = tuple(a)
print(type(b))
c = list(b)
print(type(c))
В данном случае, в продолжение сделанного ранее, мы вызвали функцию list(), передав ей в качестве аргумента переменную b, и это всё присвоили в качестве значения переменной c, которая у нас, по результатам проверки, имеет тип данных list, т.е. список.
 
 
Но вернёмся к функции tuple()
 
Когда в учебниках по программированию на Пайтоне приводят модель этой функции, то указывают её вот так: tuple([iterable])
Наблюдательный зритель сразу спросит: что это ещё за iterable такой? Нам про него ничего не говорили!
Давайте разберёмся. Тема сложная для восприятия, но достойная внимания. И я даже сейчас не уверен, что смогу эту тему изложить достаточно внятно. Но поскольку покой нам только снится, всё же попробую.
В моей интерпретации само слово iterable по-английски означает «используемый циклично» или «используемый с повторениями». Словом iterable называют признак того объекта, который можно проводить через повторения, через так называемые итерации, через циклы. Циклы мы ещё будем с Вами изучать в этом курсе. Например, циклы for и while.
Это была пара слов на тему общего значения слова „iterable“.
А теперь пришло время узнать, какие конкретно типы данных относятся к понятию iterable в Пайтоне.
Сразу скажу, что программист может практически любой объект при помощи некоторых действий сделать iterable, поэтому стоит просто определиться, какие объекты уже iterable сами по себе, без дополнительных манипуляций.
У объектов, которые являются iterable есть один признак: они поддерживают применение к себе метода __iter__.
Давайте на практике осуществим небольшое испытание: применим метод __iter__ к известным нам типам данных.
Начнём с типа данных «список» list.
a = [1, 'Words', 5.2]
print(type(a))
a.__iter__
Код выполнен без ошибок. Значит, метод __iter__ поддерживается объектом по имени a. Значит, над этим объектом можно совершать действия, которые характеризуются как циклические действия, так называемые циклы.
 
Теперь перейдём и к самому кортежу. Узнаем, присущ ли объекту типа данных кортеж такой признак, который передаётся термином iterable.
b = (1, 'Words', 5.2)
print(type(b))
b.__iter__
И снова наш код отработал без ошибок, мы можем с полной уверенностью считать кортеж типом данных с признаком iterable.
 
А давайте проверим на поддержку этого метода тип данных строка. Да не просто какую-то строку, а состоящую из всего-навсего одного слова.
c = 'John'
print(type(c))
c.__iter__
Аналогичный результат, друзья. Строка тоже поддерживает метод  .__iter__
 
А теперь давайте проверим на поддержку этого метода тип данных integer – целое число.
d = 777
print(type(d))
d.__iter__
И тут мы получаем ошибку. Мол, нет у вашего объекта такого атрибута (то есть метода) как __iter__
 
 
Итак, зачем мы провели четыре этих эксперимента? Чтобы понять, какие типы данных мы можем превратить в кортеж при помощи функции tuple([iterable]) Теперь мы знаем, что из известных нам типов, в кортежи мы можем превратить список и строку. Список мы уже превращали в кортеж в этом уроке. Осталось превратить в кортеж строку.
 
a = 'John'
print(type(a))
print(a)
b = tuple(a)
print(type(b))
print(b)
 
Ну, давайте заодно строку и в список превратим, что ли.
a = 'John'
print(type(a))
print(a)
b = list(a)
print(type(b))
print(b)
 
И чуть забегая вперёд, отмечу, что и из типа данных «словарь» можно сделать кортеж. В курсе «Ленивый питон» Вы найдёте урок про тип данных «словарь». Просто продолжайте передвигаться по урокам данного видеокурса.
 
И в завершение этого видеоурока - несколько заданий на проверку того, как была воспринята информация. Попробуйте правильно ответить на следующие вопросы.
 
 
 
 
Как Вы считаете, какой тип данных больше защищён от нежелательных изменений данных?
А) кортеж
Б) список
 
Можно ли при помощи встроенных функций Пайтона превратить другие типы данных в кортежи?
А) Да, можно
Б) Нет, нельзя
 
 
Как Вы считаете, возникнет ли ошибка при выполнении такого кода и если да, то почему она возникнет?
a = 1
b = tuple(a)
print(type(b))
Ответ: Да, ошибка возникнет. Потому что нельзя при помощи функции tuple превратить тип данных int в кортеж. Ведь тип данных int не обладает характеристикой, которая называется iterable.
 
Что означает английское слово iterable?
А) Тот, который можно использовать во время повторений или циклов. Т.е., над которым можно осуществлять повторяющиеся действия.
Б) Тот, который повторяет что-то, сам осуществляет действие повторения над чем-то.
В) Неповторный.
Г) Повторяющий или имитирующий чьи-то признаки или характеристики.
 
Как читается это английское слово: tuple?
А) Тупил
Б) Пьюпил
В) Тьяпил
Г) Тьюпл
Д) Пипл ту пипл


Урок 19

Видео:
https://www.youtube.com/watch?v=cxTC2mg6L8c&index=19&list=PLbKwBvrpogbZfU50rPMmXow3aMFjIw4gk

Материал:
Описание идеи игры “Захват Марса”. Текст можно найти здесь: https://lenivii.wordpress.com/2015/06/27/igra/






Урок 20

Видео:
https://www.youtube.com/watch?v=iEfTmPKGynM&index=21&list=PLbKwBvrpogbZfU50rPMmXow3aMFjIw4gk

Код:








Урок 21

Видео:
https://www.youtube.com/watch?v=-sYFrRxDrHE&list=PLbKwBvrpogbZfU50rPMmXow3aMFjIw4gk&index=21

Код:


"""
Lists
list = [item1, item2, item3, item4]
listtwo = [item7, item9, item15, item16]
listthree = [list, listtwo, item10]
"""

"""
bobsmith = ['Bob', 'Smith', 'Coordinator', 1000000, 1, 0, 0, 20, 'yes', 1000, 100]
marthasmith = ['Martha', 'Smith', 'Infector', 500000, 2, 1000, 10, 15, 'no', 0, 0]
johnsmith = ['John', 'Smith', 'Soldier', 500000, 2, 0, 0, 20, 'yes', 2000, 200]
smithbrigade = [bobsmith, marthasmith, johnsmith]
print(smithbrigade)
"""

b = ['text', 10, 'onemoretext', 1.5]
for object in b:
    print(object)

superlist = ['super', 'even more super', 'the superest']
for super in superlist:
    print(super)





Урок 22

Видео:
https://www.youtube.com/watch?v=qKWwZdnKhnI&list=PLbKwBvrpogbZfU50rPMmXow3aMFjIw4gk&index=22

Материал:
Цикл for

b = ['Timothy', 'Sean', 'Anthony']
order = 0
for human in b:
    print(order, '. ', human, sep = '')
    order = order + 1


b = ['Timothy', 'Sean', 'Anthony', 'Michael']
order = 1
for human in b:
    print(order, '. ', b[order], sep = '')
    order = order + 1
    




Урок 23

Видео:
https://www.youtube.com/watch?v=G3gyImDeSNE&list=PLbKwBvrpogbZfU50rPMmXow3aMFjIw4gk&index=23

Материал:
Цикл for

firstnames = ['Anthony', 'Timothy', 'Sean', 'Jim']
lastnames = ['Smith', 'Parker', 'Cameron']
temporarylist = []
i = 0
b = 0
c = 0
for item in lastnames:
for item in firstnames:
    temporarylist.insert(c, firstnames[i] + lastnames[b])
    print(temporarylist)
    i = i + 1
    c = c + 1










Урок 24

Видео:
https://www.youtube.com/watch?v=9nmpW8rWqJc&index=24&list=PLbKwBvrpogbZfU50rPMmXow3aMFjIw4gk

Материал:

Цикл for и оператор if


firstnames = ['Anthony', 'Timothy', 'Sean', 'Jim']
lastnames = ['Smith', 'Parker', 'Cameron']
temporarylist = []
i = 0
b = 0
c = 0
for item in lastnames:
    for item in firstnames:
        temporarylist.insert(c, firstnames[i] + lastnames[b])
        print(temporarylist)
        i = i + 1
        c = c + 1
    if i > len(firstnames) - 1:
        b = b + 1
        i = 0
    




Урок 25

Видео:
https://www.youtube.com/watch?v=bXQqrpX4sCc&list=PLbKwBvrpogbZfU50rPMmXow3aMFjIw4gk&index=25

Материал:
Работа с файлами. Открыть, считать, записать.

"""
Output to files

File object

file object = open(file_name [, access_mode][, buffering])

File open modes in Python:

Mode  Read? Write? Overwrites  Creates new file  Where is cursor?
                   existing    if file does not
                   file?       exist?

r       Y     N      N            N                Beginning
rb      Y     N      N            N                Beginning

r+      Y     Y      N            N                Beginning
rb+     Y     Y      N            N                Beginning

w       N     Y      Y            Y                Beginning
wb      N     Y      Y            Y                Beginning

w+      Y     Y      Y            Y                Beginning
wb+     Y     Y      Y            Y                Beginning

a       N     Y      N            Y                End
ab      N     Y      N            Y                End

a+      Y     Y      N            Y                End
ab+     Y     Y      N            Y                End

"""

workfile = open('Superfile.txt', 'a')
workfile.write("This is my first line")
workfile.write("\n")
#workfile.write("This is my second line")
workfile.close()
print('Done')




Урок 26

Видео:
https://www.youtube.com/watch?v=QP8iFaZNbRI&list=PLbKwBvrpogbZfU50rPMmXow3aMFjIw4gk&index=26

Материал:
Завершение первой версии генератора
firstnames = ['Anthony', 'Timothy']
lastnames = ['Smith', 'Parker']
temporarylist = []
i = 0
b = 0
c = 0
for item in lastnames:
    for item in firstnames:
        temporarylist.insert(c, firstnames[i] + lastnames[b])
        i = i + 1
        c = c + 1
    if i > len(firstnames) - 1:

        # Now writing current family name to Families.txt
        file = open("listoffamilies.txt", 'a')
        file.write(lastnames[b] + '\n')
        file.close()

        # Now writing chain of cyborg-names to Smith.txt, Parker.txt etc.
        print(lastnames[b], ' = ', temporarylist)
        file = open(lastnames[b] + ".txt", 'w')
        temporarylist = str(temporarylist)
        file.write(temporarylist)
        file.close()

        b = b + 1
        i = 0
        c = 0






Урок 27

Видео:
https://www.youtube.com/watch?v=BpabzIRU1J8&index=27&list=PLbKwBvrpogbZfU50rPMmXow3aMFjIw4gk

Материал:
Словари

"""

Dictionaries in Python

Sequence of key-value pairs



Model:

d = {'key': value, 'nextkey': value, 'anotherkey': value}




Advantages of dictionaries:

- Easier search, extraction and update of data
- Dictionaries can be used as databases
- Plenty of effective dictionary.methods



How to initialize/create a dictionary:

d = {}


or

d = {'key': value, 'nextkey': value, 'anotherkey': value}


E.g.
d = {'alias': 'JohnSmith', 'firstname': 'John', 'familyname': 'Smith'}
print(d)


or
d = dict(key=value, nextkey=value, anotherkey=value)

E.g. 
d = dict(alias='JohnSmith', firstname='John', familyname='John')
print(d)

or
d = dict.fromkeys(['key', 'nextkey', 'anotherkey'])

E.g. 
d = dict.fromkeys(['alias', 'firstname', 'familyname'])
print(d)

or
d = {key: value for expression}


E.g.
d = {a: 'abc' for a in range(5)}
print(d)

d = {anykey: 10 for anykey in range(5)}
print(d)

d = {a: a + 1 for a in range(5)}
print(d)


"""
d = {a: a + a for a in range(10)}
print(d)
"""

d = {a: a - 1 for a in range(5)}
print(d)

d = {a: a - a for a in range(5)}
print(d)

d = {a: a ** 2 for a in range(5)}
print(d)

d = {a: a / 2 for a in range(5)}
print(d)

#Adding values to existing dictionary

#d[key] = value
d = {0: 1, 1: 2, 2:3, 3:4, 4:5}
d[5] = 6

#d.update(otherdictionary)

dd = {6:7, 7:8}
d.update(dd)

ddd = {a: a + 1 for a in range(8, 15)}
d.update(ddd)

print(d)





Урок 28

Видео:
https://www.youtube.com/watch?v=GlUtLm24-W0&index=28&list=PLbKwBvrpogbZfU50rPMmXow3aMFjIw4gk

Материал:
Словари

# Create a mapping of country to capital
asia = {
    'Azerbaijan': 'Baku',
    'Armenia': 'Yerevan',
    'Afghanistan': 'Kabul'
    }


# Create a mapping of capital to population
population = {
    'Baku': 2137000,
    'Yerevan': 1060000,
    'Kabul': 3000000
}

# Adding some more population info (about Bangladesh and Bahrain)
population['Dhaka'] = 18000000
population['Manama'] = 157000

# Printing out some population info
print('+' * 5)
print("Baku has the population of:", population['Baku'])
print("Yerevan has the population of:", population['Yerevan'])

# Printing out info about the capital cities
print('+' * 5)
print("Azerbaijan's capital is:", asia['Azerbaijan'])
print("Armenia's capital is:", asia['Armenia'])

# Printing out the info about the population of capitals without mentioning the capitals
print( '+' * 5)
print( "Azerbaijan's capital has the population of: ", population[asia['Azerbaijan']])
print( "Armenia's capital has the population of: ", population[asia['Armenia']])


#dict.items()
#%s

# Print every Asian country's capital
print( '+' * 5)
for country, capital in asia.items():
#    print( "%s has %s" % (country, capital))
    print( "%s's capital is %s" % (country, capital))
   

# Printing every Asian capital's population
print( '+' * 5)
for capital, number in population.items():
    print( "%s has the population of %s" % (capital, number))

# Now printing both pieces of information at the same time
print('+' * 5)
for country, capital in asia.items():
    print( "%s has the capital of %s with the population of %s" % (
        country, capital, population[capital]))






Урок 29

Видео:
https://www.youtube.com/watch?v=eS4xU1oHYfQ&list=PLbKwBvrpogbZfU50rPMmXow3aMFjIw4gk&index=29

Материал:
Словари. Методы   .clear(), .copy(), .keys(), .values(), .get(). 

"""

# Create a mapping of country to capital
asia = {
    'Azerbaijan': 'Baku',
    'Armenia': 'Yerevan',
    'Afghanistan': 'Kabul'
    }


# Create a mapping of capital to population
population = {
    'Baku': 2137000,
    'Yerevan': 1060000,
    'Kabul': 3000000
    }

"""
Methods:

Clearing dictionary
dict.clear() 



print('+' * 5)
population.clear()
print(population)





# Method .copy - creating a copy of the dictionary
# dict.copy()

print('+' * 5)
countriesofasia = asia.copy()
print(asia)
print(countriesofasia)





# Method .keys - extracting only the keys from the dictionary
# dict.keys()
print('+' * 5)
#print(asia.keys())

asiaclone = asia.keys()
print(asiaclone)






# Method. values - extracting only the values from the dictionary
# dict.values()
print('+' * 5)
#print(asia.values())

asiavalues = asia.values()
print(asiavalues)

"""



# Method .get - extracting key-value pairs and doing some actions in case if the key-value pairs are not there

"""
print('+' * 5)
countryone = asia.get('Azerbaijan')
print(countryone)

countryone = asia.get('Tokyo')
print(countryone)


# Using the .get method with 'if'

print( '+' * 5)
# The case when the country is not listed:
country = asia.get('Armenia')

if not country:
    print( "Sorry, no info about this country.")

if country:
    print(country)


"""



#Adding lists as values - not always a good idea
# dict = {'key': [value, value, value], 'key2': [value, value, value]}
print('+' * 5)
citiesoffrance = {'city': ['Paris', 'Marseille', 'Lyon'], 'population': ['3M', '2M', '1M']}
#print(citiesoffrance)


#OR
print(citiesoffrance['city'][0])
print(citiesoffrance['population'][0])


#OR
print('+' * 5)
print(citiesoffrance['city'][0], citiesoffrance['population'][0])


# And here is why it is not always a good idea to include lists into dictionaries.
print( '+' * 5)
for city, population in citiesoffrance.items():
    print( "%s has the population of %s" % (city, population))



# This way would be much better
citiesoffrance = {'Paris': '3M', 'Marseille': '2M', 'Lyon':'1M'}
for city, population in citiesoffrance.items():
    print( "%s has the population of %s" % (city, population))


Урок 30

Видео:
https://www.youtube.com/watch?v=z2NbH4iorxA&index=30&list=PLbKwBvrpogbZfU50rPMmXow3aMFjIw4gk

Материал:
Словари и списки словарей

Код:
# Cases when we can use double key (double index)

AnthonySmith = {'alias': 'AnthonySmith', 'firstname': 'Anthony', 'familyname': 'Smith', 'function': 'Coordinator', 'fuelcapacity': 1000000, 'fuelusagehr': 1}

print(AnthonySmith)

AnthonySmith = {'alias': 'AnthonySmith',
'name': {'first': 'Anthony', 'family': 'Smith'},
'function': 'Coordinator',
'fuel': {'capacity': 'Anthony', 'usageperhour': 'Smith'}}

print(AnthonySmith)

name = AnthonySmith['name']
print(name)

firstname = AnthonySmith['name']['first']
print(firstname)


family = AnthonySmith['name']['family']
print(family)








Урок 31

Видео:
https://www.youtube.com/watch?v=nWEOTimJFME&index=32&list=PLbKwBvrpogbZfU50rPMmXow3aMFjIw4gk

Материал:
Словари в словарях и словари в списках


# Double key (double index)
# Двойной ключ (двойной индекс)


"""
AnthonySmith = {'alias': 'AnthonySmith', 'firstname': 'Anthony', 'familyname': 'Smith', 'function': 'Coordinator', 'fuelcapacity': 1000000, 'fuelusagehr': 1}

print(AnthonySmith)

"""


"""

AnthonySmith = {'alias': 'AnthonySmith',
'name': {'first': 'Anthony', 'family': 'Smith'},
'function': 'Coordinator',
'fuel': {'capacity': 1000000, 'usageperhour': 1}}

print(AnthonySmith)

name = AnthonySmith['name']
print(name)

firstname = AnthonySmith['name']['first']
print(firstname)

family = AnthonySmith['name']['family']
print(family)




BobSmith = {'alias': 'BobSmith',
'name': {'first': 'Bob', 'family': 'Smith'},
'function': 'Infector',
'fuel': {'capacity': 500000, 'usageperhour': 2}}


BillSmith = {'alias': 'BillSmith',
'name': {'first': 'Bill', 'family': 'Smith'},
'function': 'Soldier',
'fuel': {'capacity': 500000, 'usageperhour': 2}}

brigade = [AnthonySmith, BobSmith, BillSmith]
print(brigade)


"""

# Increase fuel reserve by two times for all the cyborgs in brigade
# Увеличить в два раза запас топлива для всех киборгов в бригаде

"""
AnthonySmith = {'alias': 'AnthonySmith',
'name': {'first': 'Anthony', 'family': 'Smith'},
'function': 'Coordinator',
'fuel': {'capacity': 1000000, 'usageperhour': 1}}

BobSmith = {'alias': 'BobSmith',
'name': {'first': 'Bob', 'family': 'Smith'},
'function': 'Infector',
'fuel': {'capacity': 500000, 'usageperhour': 2}}

BillSmith = {'alias': 'BillSmith',
'name': {'first': 'Bill', 'family': 'Smith'},
'function': 'Soldier',
'fuel': {'capacity': 500000, 'usageperhour': 2}}

brigade = [AnthonySmith, BobSmith, BillSmith]
print(brigade)

for cyborg in brigade:
    #cyborg['fuel']['capacity'] = cyborg['fuel']['capacity'] * 2
    cyborg['fuel']['capacity'] *= 2
print(brigade)

"""

# Increase fuel reserve by three times for the cyborg with the first name Anthony
# Увеличить в три раза запас топлива для киборга, которого зовут Энтони
"""

AnthonySmith = {'alias': 'AnthonySmith',
'name': {'first': 'Anthony', 'family': 'Smith'},
'function': 'Coordinator',
'fuel': {'capacity': 1000000, 'usageperhour': 1}}

BobSmith = {'alias': 'BobSmith',
'name': {'first': 'Bob', 'family': 'Smith'},
'function': 'Infector',
'fuel': {'capacity': 500000, 'usageperhour': 2}}

BillSmith = {'alias': 'BillSmith',
'name': {'first': 'Bill', 'family': 'Smith'},
'function': 'Soldier',
'fuel': {'capacity': 500000, 'usageperhour': 2}}

brigade = [AnthonySmith, BobSmith, BillSmith]
#print(brigade)


for cyborg in brigade:
    if cyborg['name']['first'] == 'Anthony':
        cyborg['fuel']['capacity'] = cyborg['fuel']['capacity'] * 3
print(brigade)

"""

# Deleting elements from dictionary
# Удаление элементов из словаря

# In case with a simple dictionary
# В случае с простым словарем
"""

AnthonySmith = {'alias': 'AnthonySmith', 'firstname': 'Anthony', 'familyname': 'Smith', 'function': 'Coordinator', 'fuelcapacity': 1000000, 'fuelusagehr': 1}
print(AnthonySmith)

del AnthonySmith['fuelcapacity']
print(AnthonySmith)

"""

# Deleting elements from dictionary
# Удаление элементов из словаря

# In case with embedded dictionaries
# В случае со вложенными словарями

"""
AnthonySmith = {'alias': 'AnthonySmith',
'name': {'first': 'Anthony', 'family': 'Smith'},
'function': 'Coordinator',
'fuel': {'capacity': 1000000, 'usageperhour': 1}}

print(AnthonySmith)

del AnthonySmith['fuel']['capacity']
print(AnthonySmith)
"""










# In case with embedded dictionaries inside the list
# В случае с вложенными словарями внутри списка

"""
AnthonySmith = {'alias': 'AnthonySmith',
'name': {'first': 'Anthony', 'family': 'Smith'},
'function': 'Coordinator',
'fuel': {'capacity': 1000000, 'usageperhour': 1}}

BobSmith = {'alias': 'BobSmith',
'name': {'first': 'Bob', 'family': 'Smith'},
'function': 'Infector',
'fuel': {'capacity': 500000, 'usageperhour': 2}}

BillSmith = {'alias': 'BillSmith',
'name': {'first': 'Bill', 'family': 'Smith'},
'function': 'Soldier',
'fuel': {'capacity': 500000, 'usageperhour': 2}}

brigade = [AnthonySmith, BobSmith, BillSmith]
print(brigade)

for cyborg in brigade:
    del cyborg['fuel']['capacity']

print(brigade)
"""



Урок 32

Видео:
https://www.youtube.com/watch?v=mfGJGCxZFNg&index=34&list=PLbKwBvrpogbZfU50rPMmXow3aMFjIw4gk

Материал:
Версия генератора “киборгов” как словарей с набором параметров alias, firstname, familyname

Код:

firstnames = ['Anthony', 'Timothy', 'Bob', 'Sean', 'John']
lastnames = ['Smith', 'Parker', 'Conrad', 'Washington', 'Kennedy']
tempdict = {}
i = 0
b = 0
for item in lastnames:
    for item in firstnames:
        tempdict = {'alias': firstnames[i] + lastnames[b], 'firstname': firstnames[i], 'familyname': lastnames[b]}
        file = open(lastnames[b] + ".txt", 'a')
        file.write(str(tempdict) + '\n')
        file.close()
        temporarydict = {}
        i = i + 1
    if i >= len(firstnames):
        file = open("Families.txt", 'a')
        file.write(lastnames[b] + '\n')
        file.close()
        b = b + 1
        i = 0



Урок 33

Видео:
https://www.youtube.com/watch?v=6wykugCMvQk&list=PLbKwBvrpogbZfU50rPMmXow3aMFjIw4gk&index=35

Материал:
Версия генератора “киборгов” как словарей с набором параметров alias, firstname, familyname, role, capacity, fuelhrusage, hardware, hardwareusage, hrdistance, weapons, ammunition, ammunitionhrusage

Задание:
Прописать при помощи комментариев объяснения того, что происходит в коде.

Код:


firstnames = ['Anthony', 'Timothy', 'Bob', 'Sean', 'John', 'Ivan', 'Sergey', 'Peter', 'Anton', 'Nikolas', 'Armen']
lastnames = ['Smith', 'Parker', 'Conrad', 'Washington', 'Kennedy']

coordinatorset = {'role': 'coordinator', 'capacity': 1000000, 'fuelhrusage': 1, 'hardware': 0, 'hardwareusage': 0, 'hrdistance': 20, 'weapons': 'Yes', 'ammunition': 1000, 'ammunitionhrusage': 100}
infectorset = {'role': 'infector', 'capacity': 500000, 'fuelhrusage': 2, 'hardware': 1000, 'hardwareusage': 10, 'hrdistance': 15, 'weapons': 'No', 'ammunition': 0, 'ammunitionhrusage': 0}
soldierset = {'role': 'soldier', 'capacity': 500000, 'fuelhrusage': 2, 'hardware': 0, 'hardwareusage': 0, 'hrdistance': 20, 'weapons': 'Yes', 'ammunition': 2000, 'ammunitionhrusage': 200}
technicianset = {'role': 'technician', 'capacity': 500000, 'fuelhrusage': 3, 'hardware': 1000, 'hardwareusage': 20, 'hrdistance': 15, 'weapons': 'Yes', 'ammunition': 1000, 'ammunitionhrusage': 100}
scoutset = {'role': 'scout', 'capacity': 1000000, 'fuelhrusage': 2, 'hardware': 0, 'hardwareusage': 0, 'hrdistance': 30, 'weapons': 'Yes', 'ammunition': 1000, 'ammunitionhrusage': 100}
workerset = {'role': 'worker', 'capacity': 500000, 'fuelhrusage': 3, 'hardware': 1500, 'hardwareusage': 40, 'hrdistance': 10, 'weapons': 'No', 'ammunition': 0, 'ammunitionhrusage': 0}

fsets = [coordinatorset, infectorset, soldierset, technicianset, scoutset, workerset]

i = 0
b = 0

for item in lastnames:
    c = 0
    for item in firstnames:
        tempdict = {'alias': firstnames[i] + lastnames[b], 'firstname': firstnames[i], 'familyname': lastnames[b]}
        if tempdict['firstname'] == 'Anthony':
            tempdict.update(coordinatorset)
        elif tempdict['firstname'] != 'Anthony' and c < len(fsets)-1:
            tempdict.update(fsets[c])
        elif tempdict['firstname'] != 'Anthony' and c == len(fsets)-1:
            tempdict.update(fsets[c])
            c = 0

        file = open(lastnames[b] + ".txt", 'a')
        file.write(str(tempdict) + '\n')
        file.close()
        temporarydict = {}
        i = i + 1
        c = c + 1


    if i >= len(firstnames):
        file = open("Families.txt", 'a')
        file.write(lastnames[b] + '\n')
        file.close()
        b = b + 1
        i = 0

Урок 34

Некоторые мелкие особенности, которым стоит уделить сегодня внимание. Данный урок не является ключевым, а, скорее, просто тренировочное занятие для закрепления.
Поработаем совсем немного с предложением print.
При помощи предложения print мы умеем выводить на экран значения переменных. В случае с математическими вычислениями это выглядело вот так:
a = 100 + 100
print(a)
Стоит обратить внимание на такую особенность. Если Вы заключите математическую операцию непосредственно в скобки предложения print, то на экран будет выведен результат операции. Конечно, если внутри скобок мы не заключим содержимое в кавычки.
Сравниваем.
print(100 * 100)
print(“100 * 100“)
 
Эту особенность можно использовать в следующих конструкциях:
print(“Сколько же будет 100 * 100“, 100 * 100)
 
Помните, мы изучали булевы операторы?
!=
<> 
> 
< 
>=
<=
 
Это операторы, которые помогают сравнивать. Наиболее правильное понимание этих операторов – эти операторы – вопросы. Всякий раз, когда мы используем эти операторы в выражениях, мы словно задаём вопрос интерпретатору Пайтон. Мы словно спрашиваем Пайтон, например, в этом выражении:
2 >= 1
 
«Правда ли, что 2 больше или равно 1?»
 
Что в этом случае должен сделать каждый порядочный интерпретатор?
 
Правильно, он должен ответить.
 
Итак, зададим следующий вопрос: «Правда ли, что если умножить сто на сто, то результат будет большим или будет равен результату возведения ста в сотую степень?»
 
print(100 * 100 >= 100 ** 100)
 
Также. Ещё одно небольшое напоминание, не связанное с предложением print.
Символ % применяется для логической операции деления по модулю (деления с остатком) и  называется в данном случае по-английски словом modulus. К операциям с вычислениями процентов этот символ никакого отношения не имеет и используется для деления по модулю совершенно случайно.
Уточнение по приоритетности операций.
Чтобы запомнить порядок операций, который существует в Пайтоне, Вам нужно выучить одну аббревиатуру.
PEMDAS
Parentheses
Exponents
Multiplication
Division
Addition
Subtraction
 
При переводе на русский эта аббревиатура будет звучать так:
СЭУДСВ
Скобки
Экспоненты, степени
Умножение
Деление
Сложение
Вычитание
 
 
Ещё один вопрос, эстетический.
Как правильно писать:
a = 10
или
a=10
Технически оба варианта верны. Однако добавление пробелов вокруг переменных, операторов и других элементов кода было придумано исключительно для удобства людей. Поэтому – когда Вы пишете код красиво, Вы пишете его красиво для себя.
 
Также поступил вопрос: существует ли простое упражнение для анализа и запоминания сложного кода?
Такое упражнение существует. Следует прочитать код построчно сверху вниз, проанализировав содержание каждой строки. А затем – прочитать код построчно снизу вверх, проанализировав содержание каждой строки. Сделав так 3-5 раз в течение 2-3 дней, Вы достаточно хорошо запомните код.
 
Ещё один вопрос касался длины названий переменных. Иногда в названиях переменных нужно использовать сразу несколько слов. Чтобы обозначить сложное понятие. Например, myblackcar, mywhitecar, mydadscar, mymomscar, Известно, что в некоторых языках программирования используется так называемый camelCase или верблюжийРегистр. Когда несколько слов пишутся вместе, но каждое новое слово пишется с заглавной буквы. В Пайтоне в таких случаях существует традиция использовать подчёркивание (по-английски оно называется underscore). Т.е.  правильно писать названия переменных в Пайтоне так: my_black_car, my_white_car, my_dads_car, my_moms_car. И, начиная с этого урока, мы будем использовать подчеркивание.
 
Также был вопрос: можно ли использовать в названии переменных только буквы или цифры тоже допускаются. Цифры допускаются, но нельзя начинать название переменной с цифры. 




Урок 35

Видео:
https://www.youtube.com/watch?v=av-EXv4J9Wc&list=PLbKwBvrpogbZfU50rPMmXow3aMFjIw4gk&index=37

Сегодня мы сделаем то, что сделать нужно было уже давно. Мы познакомимся с таким явлением как функции в Пайтоне.

Function in Python – функция в Пайтоне – так будет называться тема этого урока.

Если говорить по существу, функция это конструкция. Но если говорить _правильно_, функция это объект. Функцию в Пайтоне считают именно объектом.

Хотя, в этом и нет противоречия.

Ведь если взять, к примеру, кофеварку, то она тоже является одновременно и конструкцией, и объектом.

Кстати, именно с кофеваркой я и буду сравнивать функцию, чтобы понять, что оно такое – функция.

Представим себе современную кофеварку. Кофеварка это объект, который принимает от человека некий исходный материал - кофейное зерно или порошок молотого кофе. Также кофеварка принимает от человека воду, а из электросети – электричество.
Затем кофеварка производит определённые действия. И в итоге выдаёт человеку кофейный напиток.

Аналогично работает и функция в Пайтоне. Вместо кофейного зерна в функцию загружают так называемые «аргументы». А вместо кофейного напитка она выдаёт значение. Проведя ряд определённых действий, то есть операций.

Теперь – по порядку.

Чтобы сварить кофе, сначала нужно купить кофеварку. Или сконструировать её самостоятельно.
Точно так же, чтобы использовать функцию, сначала необходимо её сконструировать, создать.

Создание или объявление функции в Пайтоне начинается с использования словечка def. Def это сокращение от английского глагола define. А глагол define имеет значение «определить, задать, охарактеризовать, очертить, установить значние». К примеру, задать границы явления или определить понятие. По сути, можно сказать, что define значит «очертить границы явления» или даже «создать явление».

Итак, первое действие того, кто хочет создать функцию, будет выглядеть вот так.

def function_name( argument ):

Что в переводе на человеческий русский язык означает:

“Пайтон, создай мне функцию с названием function_name, которая получит от меня аргумент, который я назвал argument”. Дальше следует двоеточие, за которым указываются те операции, которые будут происходить внутри функции.

Это была модель. А реальное применение может выглядеть вот так:
 
def exponentiator(number):
	return number ** 2
 
Сначала мы задали функцию под названием exponentiator (возводящая в степень) и дали ей аргумент, который называется number, а затем мы совершили ещё один важный шаг.

В функциях традиционно используется ещё один английский глагол. Это глагол «возвращать» - return. При помощи глагола return мы инструктируем функцию, что именно она должна возращать.

Вы уже догадались, что будет делать наша функция exponentiator?  
Она будет возводить полученный аргумент, который называется number, во вторую степень, т.е. в квадрат. И возвращать результат этого возведения.

Давайте проверим. Итак, мы запускаем этот код на выполнение.
Для этого нам нужно просто ввести название функции, указав значение аргумента функции. То есть вместо слова number необходимо подставить реальное число.

exponentiator(10)

Выполнение произошло, но результат не был выведен на экран. А чтобы увидеть результат выполнения, мы должны  воспользоваться выводом на экран, т.е. использовать предложение print().

print(exponentiator(10))

Мы можем поменять значение аргумента и выполнить функцию снова.

print(exponentiator(12))

И снова.

print(exponentiator(25))
 
Несмотря на то, что людям, не знакомым с темой функций, этот пример может показаться довольно сложным, на самом деле это была очень простая функция.

Дело в том, что функция может принимать неограниченное количество аргументов разного типа. Внутри функции также могут находиться очень разные по степени сложности конструкции.
Давайте рассмотрим немного более сложный пример.

Давайте высчитаем некую сумму налога по некоей прогрессивной шкале. Давайте представим, что для суммы до 1000 единиц, ставка налога составляет 10%, а для суммы от 1001 до 5000 единиц ставка налога составляет 15%. А в случае, если сумма превышает 5001 единицу, мы ставка составит уже 20%. Мы хотим создать такую функцию, которая будет принимать в качестве аргумента значение суммы  и выдавать сумму налога.

Объявляем функцию.

def taxcalc(number):
	if number <= 1000:
    	tax = number * 0.1
	elif number >= 1001 and number <= 5000:
    	tax = number * 0.15
	elif number > 5000:
    	tax = number * 0.2
	return tax
print (taxcalc(1000))
print (taxcalc(1100))
print (taxcalc(3000))
print (taxcalc(5000))
print (taxcalc(6000))


Урок 36

Видео:

В прошлом уроке мы начали изучение функций в Питоне и теперь пришло время продолжить это увлекательное занятие.
Давайте разберёмся, из каких структурных компонентов состоит функция.
Например:
def function_name (argument):
def это ключевое слово
function_name это имя функции
argument это аргумент или список аргументов (ещё аргумент называют параметр, или список параметров) – всегда в скобках
Затем – двоеточие и новая строка.
С новой строки, с отступом в 4 пробела мы начинаем писать тело функции.
Если сравнить функцию с кофеваркой, то тело функции – это непосредственно рабочий механизм кофеварки. Тело функции содержит в себе указания, что нужно делать с попавшими в функцию аргументами (или параметрами).
Сразу следует упомянуть, что тело функции в Пайтоне не может быть пустым. Никому ведь не нужны кофеварки без механизма?
Что же делать, если Вам почему-то понадобилось объявить функцию без тела? Хотя так обычно никто не делает, но технически сделать это возможно.
Вместо тела Вы можете указать оператор pass. Его ещё называют «пустым оператором».
Таким образом, код пустой функции может выглядеть так:
def function_name (argument):
        	pass
По-английски pass классифицируется как pass statement.
То есть, Вы можете найти английскую документацию на тему pass statement в Гугле.
Предназначение оператора „pass“ становится понятным уже из значения английского глагола to pass. Его можно перевести на русский язык как «пропускать». Оператор pass используется как «заглушка» в том месте, где должен быть код, но его там не будет.
Что значит «в том месте, где должен быть код»?
Всё дело в том, что интерпретатор Пайтона имеет своё представление о синтаксисе каждого из элементов кода.
И когда Вы объявляете функцию, Пайтон знает, что Вы объявляете функцию. Потому что он видит признаки функции: использование ключевого слова def, например.
И в таком случае, интерпретатор Пайтона представляет себе, что Вы, объявив функцию, допишете её до конца. То есть функция будет содержать все элементы, которые он ожидает: ключевое слово def, имя функции, аргументы, двоеточие и тело функции.
Если такого элемента как тело функции нет, то интерпретатор Пайтона выдаст ошибку.
И вот именно такой случай будет называться ошибкой синтаксиса.
А поскольку разработчики терпеть не могут получать ошибки синтаксиса, они придумали оператор pass.
Представьте себе забавную ситуацию. Вы покупаете кофеварку, заливаете воду, засыпаете кофейные зерна, включаете, но… кофейный напиток не поступает. И так происходит несколько раз. Тогда Вы решаете разобраться, в чём же дело, берёте в руки отвертку и разбираете кофеварку. Когда Вы разобрали корпус, то вместо механизма Вы вдруг обнаруживаете… записку с надписью pass.
Вот именно для тех случаев, когда синтаксические модели, заложенные в Пайтон, требуют от Вас прописать какой-то код, а Вы этот код прописывать не планируете. Именно для этих случаев создан оператор pass.
Если всё максимально упростить, то оператор pass с точки зрения Пайтона означает следующее сообщение от программиста: «Да, я знаю, что тут должна быть команда, но на этом месте просто ничего не делай».
Теперь, когда мы разобрались с пустым оператором pass, нужно рассмотреть ещё несколько интересных моментов, касающихся функций.
Дело в том, что функция может принимать в качестве аргументов, как уже говорилось ранее, совершенно разные типы данных. В том числе, аргументами могут быть значения переменных.
Сразу рассмотрим пример.
Давайте напишем функцию, которая будет рассказывать нам, сколько бутербродов с сыром и колбасой мы можем сделать, исходя из наличия хлеба, масла, колбасы и сыра.
В этой функции мы обязательно в качестве аргументов функции используем переменные.
 
 
def butterbrott(bread_loaves, butter_grams, cheese_grams, sausage_grams):
	bread = (bread_loaves * 15) // 2
	butter = butter_grams // 5
	cheese = cheese_grams // 10
	sausage = sausage_grams // 10
	amount = min(bread, butter, cheese, sausage)
	return amount
 
print(butterbrott(10, 500, 1000, 1500))


Урок 41 

Видео: https://youtu.be/03PzbGPGJqY

Коды урока:

price = 210
weight = 3500
produced_by = 'Samsongin'
resolution = 'HD'
model = 'smsngn415'


smsngn415.price = 210
smsngn415.weight = 3500
smsngn415.produced_by = 'Samsongin'
smsngn415.resolution = 'HD'
smsngn415.model = 'smsngn415'


Урок 42

Видео: https://www.youtube.com/watch?v=2DoGiVLfdlk

Коды урока:

class rectangle_class:
        	height = 0
        	width = 0
        	def area(self):
                    	return self.height * self.width

rectangle_1 = rectangle_class()

rectangle_1.height = 2
rectangle_1.width = 2

rectangle_1.area()

rectangle_1.area



Урок 44

https://www.youtube.com/watch?v=-a0OEvhdYjw

Парсер Гугла

import requests
r = requests.get("ПОДСТАВЬ-СЮДА-АДРЕС-СТРАНИЦЫ")
print(r)
r.encoding
r.headers
r.text
text = r.text

from bs4 import BeautifulSoup as bs
soup = bs(text, ‘html.parser’)
h3 = soup(“h3”)
print(h3)

h3[0]
h3[1]
h3[2]

theresult = {}

for key, value in theresult.items():
    theresult[key] = value.replace("/url?q=", "")

theresult

for key, value in theresult.items():
    theresult[key] = value.split("&")[0]

theresult

resultfile = open("Superfile.txt", "w")
resultfile.write(str(theresult))
resultfile.close()




Урок 45

Игра “Маленький голодный питончик” aka “Змейка”

# Игра "Маленький голодный питончик"

import pygame, random, sys, time


def privet():
    error = pygame.init()
    if error[1] == 0:
        print("Hello! It's been a rainy summer, though weather is not that important so far")
    else:
        print("Errors detected!")
        sys.exit()
privet()

playSurface = pygame.display.set_mode((800, 600))
pygame.display.set_caption("A small and hungry python")
#time.sleep(56)
position = [50, 50] # Координаты питончика
body = [[80,50], [70,50], [60,50]] # Структура тела питончика
bait = [random.randrange(1, 80)*10,random.randrange(1, 60)*10]
baitVisible = True #
fpsController = pygame.time.Clock()  # Без особых пояснений
direction = 'RIGHT'
changeto = direction
score = 0 # Игровой счёт


# color = pygame.Color(r, g, b)

white = pygame.Color(255, 255, 255) # фон
black = pygame.Color(0, 0, 0) # конец игры
red = pygame.Color(255, 0, 0) # шрифт
green = pygame.Color(0, 255, 0) # питончик
blue = pygame.Color(0, 0, 255)
lightslateblue = pygame.Color(132, 112, 255) # пища для питончика

def music():
    pygame.mixer.init()
    pygame.mixer.music.load('music.mp3')
    pygame.mixer.music.play(0)

def gameOver():
    gaOFont = pygame.font.SysFont('Garamond', 48)
    gaOSurface = gaOFont.render('Game over!', True, red) #
    gaORectangular = gaOSurface.get_rect() #
    gaORectangular.midtop = (400, 25)  #
    playSurface.blit(gaOSurface, gaORectangular) #
    showScore(2)
    pygame.display.flip()
    time.sleep(8)
    pygame.quit()
    sys.exit()

def showScore(choice=1):
    scoreFont = pygame.font.SysFont('Garamond', 24)
    scoreSurface = scoreFont.render('Score: {0}'.format(score), True, red)
#   scoreSurface = scoreFont.render('Score:' + str(score), True, red)
    scoreRectangular = scoreSurface.get_rect()
    if choice == 1:
        scoreRectangular.midtop = (50, 25)
    else:
        scoreRectangular.midtop = (400, 125)
    playSurface.blit(scoreSurface, scoreRectangular)
    #pygame.display.flip()

while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_RIGHT or event.key == ord('d'):
                changeto = 'RIGHT'
            if event.key == pygame.K_LEFT or event.key == ord('a'):
                changeto = 'LEFT'
            if event.key == pygame.K_UP or event.key == ord('w'):
                changeto = 'UP'
            if event.key == pygame.K_DOWN or event.key == ord('s'):
                changeto = 'DOWN'
            if event.key == pygame.K_ESCAPE:
                #pygame.event.post(pygame.event.Event(QUIT))
                gameOver()
            if event.key == ord('m'):
                music()



# Работа с направлениями движения питончика
    if direction != 'LEFT' and changeto == 'RIGHT':
        direction = 'RIGHT'
    if direction != 'RIGHT' and changeto == 'LEFT':
        direction = 'LEFT'
    if direction != 'DOWN' and changeto == 'UP':
        direction = 'UP'
    if direction != 'UP' and changeto == 'DOWN':
        direction = 'DOWN'
# Изменение позиций в зависимости от направления
    if direction == 'RIGHT':
        position[0] += 10
    if direction == 'LEFT':
        position[0] -= 10
    if direction == 'UP':
        position[1] -= 10
    if direction == 'DOWN':
        position[1] += 10


# Работа над длиной тела питончика, увеличение в случае поедания пищи
    body.insert(0, list(position))
    if position[0] == bait[0] and position[1] == bait[1]:
        baitVisible = False
        score += 1
    else:
        body.pop()
# Видимость пищи на карте
    if baitVisible == False:
        baitVisible = True
        bait = [random.randrange(1, 80) * 10, random.randrange(1, 60) * 10]

    playSurface.fill(white)
    for element in body:
        pygame.draw.rect(playSurface, green, pygame.Rect(element[0], element[1], 10, 10))

# Прорисовываем пищу для питончика
    pygame.draw.rect(playSurface, lightslateblue, pygame.Rect(bait[0], bait[1], 10, 10))

# Запрещаем питончику покидать пределы игрового поля
    if position[0] > 790 or position[0] < 0:
        position[0] = 400
    if position[1] > 590 or position[1] < 0:
        position[1] = 300

# Лишаем питончика возможности кушать самого себя
# Внимание! Задание 1. В комментариях объясните логику первых двух строк этого блока
    for element in body[1: ]:
        if position[0] == element[0] and position[1] == element[1]:
            position = [50, 50]  # Координаты питончика
            body = [[80, 50], [70, 50], [60, 50]]  # Структура тела питончика

    showScore()
    pygame.display.flip()
    fpsController.tick(12)
# gameOver()

# Внимание! Задание 2. Переделайте код так, чтобы вместо игрового счёта (score)
# на экране показывалась длина тела питончика (length)

# Внимание! Задание 3. Исправьте ошибку в коде, чтобы при вызове функции
# gameOver() счёт не показывался на экране дважды

# Внимание! Задание 4* Детально и поэтапно объясните все события внутри функции gameOver()
# Сделайте видео, загрузите на Youtube и самое лучшее объяснение я включу его в Playlist

# Внимание! Задание 5  Просмотрите видео и найдите, какая ошибка регулярно возникала при выходе из игры.
# (На экране появлялось сообщение об ошибке). Попробуйте узнать, почему она возникала.

# Внимание! Задание 6  Добавьте музыкального функционала. Т.е. отключать музыку, зациклить музыку.



